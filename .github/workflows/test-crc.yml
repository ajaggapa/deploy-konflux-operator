name: Test on OpenShift CRC

on:
  push:
    branches:
      - testworkflow
  pull_request:
    branches:
      - testworkflow
  workflow_dispatch:
    branches:
      - testworkflow

jobs:
  test-crc:
    name: Test deploy-operator.sh on CRC
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            curl \
            wget \
            tar \
            gzip \
            libvirt-daemon-system \
            libvirt-clients \
            qemu-kvm \
            qemu-utils \
            qemu-system-common \
            libguestfs-tools \
            dnsmasq \
            netcat-openbsd \
            jq \
            podman \
            build-essential
          
          # Install virtiofsd - REQUIRED for CRC to work with virtiofs
          # On Ubuntu 22.04+, virtiofsd is a STANDALONE package (not in qemu packages)
          echo "Installing virtiofsd package (required for CRC)..."
          sudo apt-get install -y virtiofsd || {
            echo "virtiofsd package not found, trying alternative installation..."
            # Try installing from universe repository
            sudo add-apt-repository -y universe || true
            sudo apt-get update
            sudo apt-get install -y virtiofsd || {
              echo "Still failed, trying to install from Rust/cargo..."
              # Install Rust and build virtiofsd from source as last resort
              curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
              source $HOME/.cargo/env
              cargo install virtiofsd || true
            }
          }
          
          # Verify virtiofsd is installed
          if command -v virtiofsd &> /dev/null; then
            echo "virtiofsd installed successfully: $(which virtiofsd)"
            virtiofsd --version || true
          else
            # Search for it in common locations
            VIRTIOFSD_PATH=$(find /usr -name virtiofsd -type f 2>/dev/null | head -1)
            if [ -n "$VIRTIOFSD_PATH" ]; then
              echo "Found virtiofsd at: $VIRTIOFSD_PATH"
              sudo ln -sf "$VIRTIOFSD_PATH" /usr/bin/virtiofsd || true
            else
              echo "ERROR: virtiofsd not found! CRC will fail."
              echo "Available packages:"
              apt-cache search virtiofsd || true
            fi
          fi
          
          # Add user to libvirt group early so it's available for CRC setup
          sudo usermod -a -G libvirt $USER
          # Verify group membership
          groups

      - name: Install OpenShift CLI (oc) and opm
        run: |
          # Try to get the OpenShift version from CRC release info
          echo "Fetching CRC release information..."
          CRC_INFO=$(curl -s --max-time 10 https://developers.redhat.com/content-gateway/rest/mirror/pub/openshift-v4/clients/crc/latest/release-info.json || echo "")
          
          if [ -n "$CRC_INFO" ] && echo "$CRC_INFO" | jq -e '.version.openshiftVersion' >/dev/null 2>&1; then
            OCP_FULL_VERSION=$(echo "$CRC_INFO" | jq -r '.version.openshiftVersion')
            OCP_MINOR_VERSION=$(echo "$OCP_FULL_VERSION" | cut -d. -f1-2)
            echo "CRC will deploy OpenShift ${OCP_FULL_VERSION}, installing matching oc and opm..."
          else
            echo "Could not determine OpenShift version from CRC info, using latest stable versions"
            OCP_FULL_VERSION="latest"
            OCP_MINOR_VERSION="latest"
          fi
          
          # Function to download and extract with validation
          download_and_extract() {
            local url=$1
            local dest_dir=$2
            local tool_name=$3
            local temp_file=$(mktemp)
            local extract_dir=$(mktemp -d)
            
            echo "Downloading from: $url"
            if ! curl -f -sL "$url" -o "$temp_file"; then
              echo "Failed to download (curl error)"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
            
            # Check file size (should be > 0)
            if [ ! -s "$temp_file" ]; then
              echo "Downloaded file is empty"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
            
            # Check if file is HTML (404 page)
            if head -1 "$temp_file" 2>/dev/null | grep -qE "<!DOCTYPE|<html"; then
              echo "Downloaded file appears to be HTML (likely 404)"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
            
            # Check if it's a valid gzip file
            if ! gzip -t "$temp_file" 2>/dev/null; then
              echo "File is not a valid gzip archive"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
            
            # Extract to temp directory first
            if ! tar -xzf "$temp_file" -C "$extract_dir" 2>/dev/null; then
              echo "Failed to extract archive"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
            
            # Find and move the binary to destination
            # For opm, it might be named opm-rhel8 or opm-rhel9, so search for any opm* file
            if [ "$tool_name" = "opm" ]; then
              local binary_path=$(find "$extract_dir" -type f -name "opm*" ! -name "*.md" ! -name "*.txt" 2>/dev/null | head -1)
            else
              local binary_path=$(find "$extract_dir" -type f -name "$tool_name" 2>/dev/null | head -1)
            fi
            
            if [ -n "$binary_path" ] && [ -f "$binary_path" ]; then
              sudo mv "$binary_path" "$dest_dir/$tool_name" 2>/dev/null
              sudo chmod +x "$dest_dir/$tool_name" 2>/dev/null
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 0
            else
              echo "Binary $tool_name not found in archive"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
          }
          
          # Install oc CLI - try multiple URL formats
          echo "Installing oc CLI..."
          OCP_OC_INSTALLED=false
          
          # Build URL list - always try latest first, then version-specific if available
          if [ "$OCP_FULL_VERSION" != "latest" ] && [ -n "$OCP_MINOR_VERSION" ] && [ "$OCP_MINOR_VERSION" != "latest" ]; then
            URL_LIST=(
              "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest/openshift-client-linux.tar.gz"
              "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest-${OCP_MINOR_VERSION}/openshift-client-linux.tar.gz"
              "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/${OCP_FULL_VERSION}/openshift-client-linux.tar.gz"
            )
          else
            URL_LIST=(
              "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest/openshift-client-linux.tar.gz"
            )
          fi
          
          for url in "${URL_LIST[@]}"; do
            if download_and_extract "$url" "/usr/local/bin" "oc"; then
              OCP_OC_INSTALLED=true
              break
            fi
          done
          
          if [ "$OCP_OC_INSTALLED" = false ]; then
            echo "ERROR: Failed to install oc CLI from any URL"
            exit 1
          fi
          oc version --client
          
          # Install opm - try multiple URL formats
          echo "Installing opm..."
          OPM_INSTALLED=false
          
          # Build URL list - always try latest first, then version-specific if available
          if [ "$OCP_FULL_VERSION" != "latest" ] && [ -n "$OCP_MINOR_VERSION" ] && [ "$OCP_MINOR_VERSION" != "latest" ]; then
            OPM_URL_LIST=(
              "https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/latest/opm-linux.tar.gz"
              "https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/latest-${OCP_MINOR_VERSION}/opm-linux.tar.gz"
              "https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/${OCP_FULL_VERSION}/opm-linux.tar.gz"
            )
          else
            OPM_URL_LIST=(
              "https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/latest/opm-linux.tar.gz"
            )
          fi
          
          for url in "${OPM_URL_LIST[@]}"; do
            if download_and_extract "$url" "/usr/local/bin" "opm"; then
              OPM_INSTALLED=true
              break
            fi
          done
          
          if [ "$OPM_INSTALLED" = false ]; then
            echo "ERROR: Failed to install opm from any URL"
            exit 1
          fi
          opm version

      - name: Install CRC
        run: |
          # Try to get CRC version from API, with fallback
          echo "Fetching CRC release information..."
          CRC_INFO=$(curl -s --max-time 10 --retry 3 https://developers.redhat.com/content-gateway/rest/mirror/pub/openshift-v4/clients/crc/latest/release-info.json || echo "")
          
          if [ -n "$CRC_INFO" ] && echo "$CRC_INFO" | jq -e '.version.crcVersion' >/dev/null 2>&1; then
            CRC_VERSION=$(echo "$CRC_INFO" | jq -r '.version.crcVersion')
            echo "Found CRC version from API: $CRC_VERSION"
          else
            # Fallback: try to get latest version from directory listing or use a known working version
            echo "Could not get version from API, trying fallback method..."
            # Try to use the links from the API response if available
            if [ -n "$CRC_INFO" ] && echo "$CRC_INFO" | jq -e '.links.linux' >/dev/null 2>&1; then
              CRC_URL=$(echo "$CRC_INFO" | jq -r '.links.linux')
              echo "Using direct download URL from API: $CRC_URL"
              wget -q "$CRC_URL" -O crc-linux-amd64.tar.xz
            else
              # Last resort: try a known recent version
              echo "Using fallback: trying to download latest CRC directly..."
              CRC_VERSION="2.56.0"  # Known working version as fallback
              echo "Using fallback version: $CRC_VERSION"
              wget -q "https://developers.redhat.com/content-gateway/file/pub/openshift-v4/clients/crc/${CRC_VERSION}/crc-linux-amd64.tar.xz" || {
                echo "ERROR: Failed to download CRC archive with fallback version"
                exit 1
              }
            fi
          fi
          
          # Download if we have a version but haven't downloaded yet
          if [ -z "$CRC_URL" ] && [ -n "$CRC_VERSION" ]; then
            echo "Installing CRC version: $CRC_VERSION"
            wget -q "https://developers.redhat.com/content-gateway/file/pub/openshift-v4/clients/crc/${CRC_VERSION}/crc-linux-amd64.tar.xz" || {
              echo "ERROR: Failed to download CRC archive"
              exit 1
            }
          fi
          
          if [ ! -f "crc-linux-amd64.tar.xz" ]; then
            echo "ERROR: CRC archive file not found after download"
            exit 1
          fi
          
          echo "Extracting CRC archive..."
          tar -xJf crc-linux-amd64.tar.xz || {
            echo "ERROR: Failed to extract CRC archive"
            exit 1
          }
          
          # Find the extracted directory
          CRC_DIR=$(find . -maxdepth 1 -type d -name "crc-linux-*" | head -1)
          if [ -z "$CRC_DIR" ] || [ ! -f "$CRC_DIR/crc" ]; then
            echo "ERROR: CRC binary not found in extracted archive"
            ls -la
            exit 1
          fi
          
          sudo mv "$CRC_DIR/crc" /usr/local/bin/
          rm -rf crc-linux-* crc-linux-amd64.tar.xz
          
          crc version

      - name: Setup CRC
        run: |
          # Configure CRC (use lower memory for GitHub Actions runners)
          crc config set consent-telemetry no
          crc config set memory 12288  # 12GB - GitHub Actions runners have ~16GB
          crc config set cpus 4        # Reduce CPUs to match available resources
          crc config set disk-size 50  # Reduce disk size
          
          # Set CRC cache directory to /mnt which has more space (66GB available)
          # This avoids "no space left on device" errors during bundle extraction
          # CRC uses ~/.crc/cache for temporary extraction, so we need to symlink it
          export CRC_CACHE_DIR=/mnt/crc-cache
          sudo mkdir -p "$CRC_CACHE_DIR"
          sudo chown -R $USER:$USER "$CRC_CACHE_DIR"
          # Create symlink from default cache location to /mnt to use larger disk
          mkdir -p ~/.crc
          if [ -d ~/.crc/cache ] && [ ! -L ~/.crc/cache ]; then
            # Move existing cache if it exists
            sudo mv ~/.crc/cache "$CRC_CACHE_DIR/old-cache" || true
          fi
          # Create symlink so CRC uses /mnt for cache (including tmp-extract)
          ln -sfn "$CRC_CACHE_DIR" ~/.crc/cache
          echo "CRC cache directory set to: $CRC_CACHE_DIR (symlinked from ~/.crc/cache)"
          df -h "$CRC_CACHE_DIR"
          
          # Setup CRC (download and extract bundle)
          # Use 'sg libvirt' to run in libvirt group context (non-interactive)
          # sg works because user is already in libvirt group (added in Install dependencies)
          sg libvirt -c "CRC_CACHE_DIR=$CRC_CACHE_DIR crc setup" || {
            echo "Warning: sg failed, trying runuser..."
            sudo runuser -u $USER -g libvirt -- sh -c "CRC_CACHE_DIR=$CRC_CACHE_DIR crc setup" || {
              echo "Warning: runuser failed, trying direct crc setup..."
              CRC_CACHE_DIR=$CRC_CACHE_DIR crc setup || {
                echo "CRC setup failed. Attempting to work around group check..."
                CRC_CACHE_DIR=$CRC_CACHE_DIR CRC_SKIP_CHECK_LIBVIRT_GROUP=true crc setup || true
              }
            }
          }
          
          # FIX: Make CRC cache directory and VM disk image accessible to qemu
          # libvirt runs qemu as a different user that needs read access to the disk images
          echo "Fixing permissions for libvirt/qemu access..."
          sudo chmod -R o+rx ~/.crc/cache/ || true
          sudo chmod -R o+rx "$CRC_CACHE_DIR" || true
          # Also ensure the home directory itself is traversable
          chmod o+x ~/ || true
          # Verify permissions
          ls -la ~/.crc/cache/ || true
          
          # Disable AppArmor for libvirt-qemu if it's causing issues
          # AppArmor can prevent qemu from accessing files outside its allowed paths
          if [ -f /etc/apparmor.d/usr.sbin.libvirtd ]; then
            echo "Disabling AppArmor for libvirt..."
            sudo ln -sf /etc/apparmor.d/usr.sbin.libvirtd /etc/apparmor.d/disable/ 2>/dev/null || true
            sudo apparmor_parser -R /etc/apparmor.d/usr.sbin.libvirtd 2>/dev/null || true
          fi
          if [ -f /etc/apparmor.d/libvirt/TEMPLATE.qemu ]; then
            echo "Disabling AppArmor for QEMU..."
            sudo aa-complain /etc/apparmor.d/libvirt/TEMPLATE.qemu 2>/dev/null || true
          fi
          # Try setting libvirt to run qemu as root to avoid permission issues
          if [ -f /etc/libvirt/qemu.conf ]; then
            echo "Configuring libvirt to run qemu with elevated permissions..."
            sudo sed -i 's/#user = "root"/user = "root"/' /etc/libvirt/qemu.conf || true
            sudo sed -i 's/#group = "root"/group = "root"/' /etc/libvirt/qemu.conf || true
            sudo sed -i 's/user = "libvirt-qemu"/user = "root"/' /etc/libvirt/qemu.conf || true
            sudo sed -i 's/group = "libvirt-qemu"/group = "root"/' /etc/libvirt/qemu.conf || true
            sudo systemctl restart libvirtd || true
          fi
          
          # Ensure crc-admin-helper has correct permissions (SUID bit and root ownership required)
          # This must be done after crc setup creates the file
          if [ -f ~/.crc/bin/crc-admin-helper-linux-amd64 ]; then
            echo "Setting SUID bit and root ownership on crc-admin-helper..."
            # CRC requires crc-admin-helper to be owned by root with SUID bit set
            sudo chown root:root ~/.crc/bin/crc-admin-helper-linux-amd64 || true
            sudo chmod u+s ~/.crc/bin/crc-admin-helper-linux-amd64 || sudo chmod 4755 ~/.crc/bin/crc-admin-helper-linux-amd64 || true
            # Verify the permissions were set correctly
            ls -l ~/.crc/bin/crc-admin-helper-linux-amd64 || true
          else
            echo "Warning: crc-admin-helper not found at ~/.crc/bin/crc-admin-helper-linux-amd64"
            echo "Listing ~/.crc/bin/ contents:"
            ls -la ~/.crc/bin/ || true
          fi

      - name: Start CRC cluster
        env:
          CRC_PULL_SECRET: ${{ secrets.CRC_PULL_SECRET }}
        run: |
          # CRC requires a pull secret to start - fail early if not provided
          if [ -z "$CRC_PULL_SECRET" ]; then
            echo "ERROR: CRC_PULL_SECRET is required but not set."
            echo "CRC cannot start without a pull secret in non-interactive environments."
            echo "Please add your pull secret to GitHub secrets:"
            echo "  1. Go to https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "  2. Add a new secret named 'CRC_PULL_SECRET'"
            echo "  3. Paste your pull secret from https://console.redhat.com/openshift/create/local"
            exit 1
          fi
          
          # Set CRC cache directory to /mnt which has more space (66GB available)
          export CRC_CACHE_DIR=/mnt/crc-cache
          sudo mkdir -p "$CRC_CACHE_DIR"
          sudo chown -R $USER:$USER "$CRC_CACHE_DIR"
          echo "CRC cache directory set to: $CRC_CACHE_DIR"
          
          # Clean up any incomplete extractions from previous attempts
          echo "Cleaning up incomplete CRC extractions..."
          rm -rf ~/.crc/cache/tmp-extract/* || true
          rm -rf "$CRC_CACHE_DIR/tmp-extract/*" || true
          
          # Clean up disk space before starting CRC (GitHub Actions runners have limited disk space)
          echo "Cleaning up disk space before starting CRC..."
          df -h
          # Remove unnecessary packages and caches
          sudo apt-get clean || true
          sudo rm -rf /var/lib/apt/lists/* || true
          # Clean up any temporary files
          sudo rm -rf /tmp/* /var/tmp/* || true
          # Clean up Docker/Podman images if any
          podman system prune -af --volumes 2>/dev/null || true
          # Show available disk space
          echo "Available disk space after cleanup:"
          df -h
          echo "CRC cache directory space:"
          df -h "$CRC_CACHE_DIR"
          
          # Ensure crc-admin-helper has correct permissions (SUID bit and root ownership required)
          # Double-check permissions before starting CRC
          if [ -f ~/.crc/bin/crc-admin-helper-linux-amd64 ]; then
            echo "Verifying crc-admin-helper permissions before starting CRC..."
            # CRC requires crc-admin-helper to be owned by root with SUID bit set
            sudo chown root:root ~/.crc/bin/crc-admin-helper-linux-amd64 || true
            sudo chmod u+s ~/.crc/bin/crc-admin-helper-linux-amd64 2>/dev/null || true
            sudo chmod 4755 ~/.crc/bin/crc-admin-helper-linux-amd64 || true
            # Verify the permissions
            ls -l ~/.crc/bin/crc-admin-helper-linux-amd64 || true
            # Check if SUID bit is set and owned by root
            if [ -u ~/.crc/bin/crc-admin-helper-linux-amd64 ]; then
              OWNER=$(stat -c '%U' ~/.crc/bin/crc-admin-helper-linux-amd64 2>/dev/null || echo "unknown")
              if [ "$OWNER" = "root" ]; then
                echo "SUID bit and root ownership are correctly set on crc-admin-helper"
              else
                echo "WARNING: crc-admin-helper is not owned by root (owner: $OWNER), fixing..."
                sudo chown root:root ~/.crc/bin/crc-admin-helper-linux-amd64
                ls -l ~/.crc/bin/crc-admin-helper-linux-amd64 || true
              fi
            else
              echo "WARNING: SUID bit is NOT set on crc-admin-helper, trying to fix..."
              sudo chown root:root ~/.crc/bin/crc-admin-helper-linux-amd64
              sudo chmod u+s ~/.crc/bin/crc-admin-helper-linux-amd64
              ls -l ~/.crc/bin/crc-admin-helper-linux-amd64 || true
            fi
          else
            echo "ERROR: crc-admin-helper not found! CRC setup may have failed."
            exit 1
          fi
          
          # Write pull secret to CRC's expected location
          # CRC expects the pull secret at ~/.crc/pull-secret.txt
          mkdir -p ~/.crc
          echo "$CRC_PULL_SECRET" > ~/.crc/pull-secret.txt
          chmod 600 ~/.crc/pull-secret.txt
          
          # Helper functions to ensure every CRC command runs inside the libvirt group context.
          cat <<'EOF' >/tmp/crc-libvirt-utils.sh
run_crc_cmd() {
  local cmd="$*"
  if sg libvirt -c "$cmd"; then
    return 0
  fi
  if sudo runuser -u $USER -g libvirt -- bash -c "$cmd"; then
    return 0
  fi
  CRC_SKIP_CHECK_LIBVIRT_GROUP=true bash -c "$cmd"
}

run_crc_cmd_capture() {
  local cmd="$*"
  local output
  if output=$(sg libvirt -c "$cmd"); then
    printf '%s\n' "$output"
    return 0
  fi
  if output=$(sudo runuser -u $USER -g libvirt -- bash -c "$cmd"); then
    printf '%s\n' "$output"
    return 0
  fi
  output=$(CRC_SKIP_CHECK_LIBVIRT_GROUP=true bash -c "$cmd")
  local status=$?
  printf '%s\n' "$output"
  return $status
}
EOF
          echo "CRC_LIBVIRT_HELPER=/tmp/crc-libvirt-utils.sh" >> "$GITHUB_ENV"
          # shellcheck disable=SC1090
          source /tmp/crc-libvirt-utils.sh

          # Start CRC with pull secret using libvirt group context helper
          echo "Starting CRC cluster (with libvirt group helper)..."
          if run_crc_cmd "CRC_CACHE_DIR=$CRC_CACHE_DIR crc start -p ~/.crc/pull-secret.txt"; then
            CRC_START_SUCCESS=true
          else
            CRC_START_SUCCESS=false
          fi
          
          if [ "$CRC_START_SUCCESS" != "true" ]; then
            echo "ERROR: All attempts to start CRC failed!"
            echo "Checking CRC status..."
            run_crc_cmd "crc status" || true
            echo "Checking disk space..."
            df -h
            echo "Checking CRC cache directory space..."
            df -h "$CRC_CACHE_DIR" || true
            echo "Checking if pull secret file exists..."
            ls -la ~/.crc/pull-secret.txt || true
            exit 1
          fi
          
          if [ "$CRC_START_SUCCESS" = "true" ]; then
            echo "CRC started successfully!"
            
            # Wait for cluster to be ready
            echo "Waiting for cluster to be ready..."
            timeout 300 bash -c 'until oc get nodes 2>/dev/null; do sleep 10; done' || {
              echo "ERROR: Cluster did not become ready within timeout"
              crc status || true
              exit 1
            }
            
            # Configure oc environment
            eval "$(run_crc_cmd_capture 'crc oc-env')"
            
            # Login as admin with up to 5 retries to work around CRC race conditions
            echo "Logging into cluster as kubeadmin (will retry on transient errors)..."
            LOGIN_MAX_RETRIES=5
            LOGIN_SLEEP=15
            LOGIN_SUCCESS=false
            LOGIN_PASSWORD=$(run_crc_cmd_capture 'crc console --credentials' | grep -oP 'password: \K.*')
            for attempt in $(seq 1 $LOGIN_MAX_RETRIES); do
              echo "Attempt $attempt/$LOGIN_MAX_RETRIES"
              if oc login -u kubeadmin -p "$LOGIN_PASSWORD" https://api.crc.testing:6443 --insecure-skip-tls-verify; then
                LOGIN_SUCCESS=true
                break
              fi
              echo "Login failed, retrying in ${LOGIN_SLEEP}s..."
              sleep $LOGIN_SLEEP
            done
            if [ "$LOGIN_SUCCESS" != "true" ]; then
              echo "ERROR: Failed to login to cluster after $LOGIN_MAX_RETRIES attempts"
              exit 1
            fi
            
            # Wait for cluster operators to be ready
            echo "Waiting for cluster operators to be ready..."
            timeout 600 bash -c 'until oc get clusteroperators 2>/dev/null && oc wait --for=condition=Available --timeout=5s clusteroperators --all 2>/dev/null; do sleep 30; done' || echo "Warning: Cluster operators may not be fully ready"
          else
            echo "ERROR: CRC start failed!"
            exit 1
          fi

      - name: Verify cluster access
        run: |
          load_crc_helpers() {
            if [ -n "$CRC_LIBVIRT_HELPER" ] && [ -f "$CRC_LIBVIRT_HELPER" ]; then
              # shellcheck disable=SC1090
              source "$CRC_LIBVIRT_HELPER"
            else
              run_crc_cmd() { bash -c "$*"; }
              run_crc_cmd_capture() {
                local output
                output=$(bash -c "$*")
                local status=$?
                printf '%s\n' "$output"
                return $status
              }
            fi
          }
          load_crc_helpers

          # Check if CRC is running
          if ! run_crc_cmd "crc status" &>/dev/null; then
            echo "ERROR: CRC cluster is not running!"
            run_crc_cmd "crc status" || true
            exit 1
          fi
          
          # Configure oc environment
          eval "$(run_crc_cmd_capture 'crc oc-env')"
          
          # Login as admin
          oc login -u kubeadmin -p "$(run_crc_cmd_capture 'crc console --credentials' | grep -oP 'password: \K.*')" https://api.crc.testing:6443 --insecure-skip-tls-verify || {
            echo "ERROR: Failed to login to cluster"
            exit 1
          }
          
          echo "=========================================="
          echo "Cluster Information:"
          echo "=========================================="
          oc get nodes || {
            echo "ERROR: Failed to get nodes"
            exit 1
          }
          echo ""
          echo "OpenShift Version:"
          oc version -o json | jq -r '.openshiftVersion // "unknown"'
          echo ""
          echo "Client Version:"
          oc version --client
          echo ""
          echo "Cluster Operators:"
          oc get clusteroperators

      - name: Make script executable
        run: |
          chmod +x deploy-operator.sh

      - name: Test script with KONFLUX_SKIP_DEPLOYMENT
        env:
          QUAY_AUTH: ${{ secrets.QUAY_AUTH }}
        run: |
          load_crc_helpers() {
            if [ -n "$CRC_LIBVIRT_HELPER" ] && [ -f "$CRC_LIBVIRT_HELPER" ]; then
              # shellcheck disable=SC1090
              source "$CRC_LIBVIRT_HELPER"
            else
              run_crc_cmd() { bash -c "$*"; }
              run_crc_cmd_capture() {
                local output
                output=$(bash -c "$*")
                local status=$?
                printf '%s\n' "$output"
                return $status
              }
            fi
          }
          load_crc_helpers

          eval "$(run_crc_cmd_capture 'crc oc-env')"
          oc login -u kubeadmin -p "$(run_crc_cmd_capture 'crc console --credentials' | grep -oP 'password: \K.*')" https://api.crc.testing:6443 --insecure-skip-tls-verify
          
          # Test 1: Skip deployment (metadata extraction only)
          echo "=== Test 1: KONFLUX_SKIP_DEPLOYMENT=true ==="
          KONFLUX_SKIP_DEPLOYMENT=true ./deploy-operator.sh --operator sriov || echo "Test completed"
          
          # Test 2: Skip operator deployment (CatalogSource only)
          echo "=== Test 2: KONFLUX_DEPLOY_OPERATOR=false ==="
          if [ -n "$QUAY_AUTH" ]; then
            KONFLUX_DEPLOY_OPERATOR=false ./deploy-operator.sh --operator sriov --quay-auth <(echo "$QUAY_AUTH") || echo "Test completed"
          else
            echo "Skipping test - QUAY_AUTH not set"
          fi
          
          # Test 3: FBC tag mode (use detected OCP version)
          echo "=== Test 3: FBC tag mode ==="
          OCP_VER=$(oc version -o json | jq -r '.openshiftVersion' | cut -d. -f1-2 || echo "4.20")
          KONFLUX_SKIP_DEPLOYMENT=true ./deploy-operator.sh --fbc-tag ocp__${OCP_VER}__metallb-rhel9-operator || echo "Test completed"

      - name: Test script validation
        run: |
          # Test script argument validation
          echo "=== Testing argument validation ==="
          
          # Should fail: no arguments
          ./deploy-operator.sh 2>&1 | grep -q "Provide either" && echo "✓ Correctly rejects missing arguments" || echo "✗ Failed to reject missing arguments"
          
          # Should fail: both --operator and --fbc-tag
          ./deploy-operator.sh --operator sriov --fbc-tag test 2>&1 | grep -q "not both" && echo "✓ Correctly rejects both arguments" || echo "✗ Failed to reject both arguments"
          
          # Should fail: invalid operator
          ./deploy-operator.sh --operator invalid-operator 2>&1 | grep -q "Invalid operator" && echo "✓ Correctly rejects invalid operator" || echo "✗ Failed to reject invalid operator"

      - name: Test with KONFLUX_SKIP_DEPLOYMENT
        run: |
          load_crc_helpers() {
            if [ -n "$CRC_LIBVIRT_HELPER" ] && [ -f "$CRC_LIBVIRT_HELPER" ]; then
              # shellcheck disable=SC1090
              source "$CRC_LIBVIRT_HELPER"
            else
              run_crc_cmd() { bash -c "$*"; }
              run_crc_cmd_capture() {
                local output
                output=$(bash -c "$*")
                local status=$?
                printf '%s\n' "$output"
                return $status
              }
            fi
          }
          load_crc_helpers

          eval "$(run_crc_cmd_capture 'crc oc-env')"
          oc login -u kubeadmin -p "$(run_crc_cmd_capture 'crc console --credentials' | grep -oP 'password: \K.*')" https://api.crc.testing:6443 --insecure-skip-tls-verify
          
          echo "=== Testing KONFLUX_SKIP_DEPLOYMENT ==="
          KONFLUX_SKIP_DEPLOYMENT=true ./deploy-operator.sh --operator sriov 2>&1 | grep -q "Skipping deployment" && echo "✓ Correctly skips deployment" || echo "✗ Failed to skip deployment"

      - name: Test environment variable controls
        env:
          QUAY_AUTH: ${{ secrets.QUAY_AUTH }}
        run: |
          load_crc_helpers() {
            if [ -n "$CRC_LIBVIRT_HELPER" ] && [ -f "$CRC_LIBVIRT_HELPER" ]; then
              # shellcheck disable=SC1090
              source "$CRC_LIBVIRT_HELPER"
            else
              run_crc_cmd() { bash -c "$*"; }
              run_crc_cmd_capture() {
                local output
                output=$(bash -c "$*")
                local status=$?
                printf '%s\n' "$output"
                return $status
              }
            fi
          }
          load_crc_helpers

          eval "$(run_crc_cmd_capture 'crc oc-env')"
          oc login -u kubeadmin -p "$(run_crc_cmd_capture 'crc console --credentials' | grep -oP 'password: \K.*')" https://api.crc.testing:6443 --insecure-skip-tls-verify
          
          echo "=== Testing environment variable controls ==="
          
          # Test KONFLUX_DEPLOY_CATALOG_SOURCE=false and KONFLUX_DEPLOY_OPERATOR=false
          if [ -n "$QUAY_AUTH" ]; then
            KONFLUX_DEPLOY_CATALOG_SOURCE=false KONFLUX_DEPLOY_OPERATOR=false \
              ./deploy-operator.sh --operator sriov --quay-auth <(echo "$QUAY_AUTH") 2>&1 | head -20 || echo "Environment variable test completed"
          else
            echo "Skipping test - QUAY_AUTH not set"
          fi

      - name: Cleanup CRC (if needed)
        if: always()
        run: |
          load_crc_helpers() {
            if [ -n "$CRC_LIBVIRT_HELPER" ] && [ -f "$CRC_LIBVIRT_HELPER" ]; then
              # shellcheck disable=SC1090
              source "$CRC_LIBVIRT_HELPER"
            else
              run_crc_cmd() { bash -c "$*"; }
              run_crc_cmd_capture() {
                local output
                output=$(bash -c "$*")
                local status=$?
                printf '%s\n' "$output"
                return $status
              }
            fi
          }
          load_crc_helpers

          # Stop CRC to free resources
          run_crc_cmd "crc stop" || true
          run_crc_cmd "crc delete -f" || true

      - name: Archive logs
        if: failure()
        run: |
          load_crc_helpers() {
            if [ -n "$CRC_LIBVIRT_HELPER" ] && [ -f "$CRC_LIBVIRT_HELPER" ]; then
              # shellcheck disable=SC1090
              source "$CRC_LIBVIRT_HELPER"
            else
              run_crc_cmd() { bash -c "$*"; }
              run_crc_cmd_capture() {
                local output
                output=$(bash -c "$*")
                local status=$?
                printf '%s\n' "$output"
                return $status
              }
            fi
          }
          load_crc_helpers

          eval "$(run_crc_cmd_capture 'crc oc-env')" || true
          mkdir -p /tmp/crc-logs
          run_crc_cmd "crc logs --bundle /tmp/crc-logs/crc-logs.tar.gz" || true
          # Upload logs as artifact (optional)
          echo "CRC logs saved to /tmp/crc-logs/"

