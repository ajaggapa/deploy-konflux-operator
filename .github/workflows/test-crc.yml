name: Test on OpenShift CRC

on:
  push:
    branches:
      - testworkflow
  pull_request:
    branches:
      - testworkflow
  workflow_dispatch:
    branches:
      - testworkflow

jobs:
  test-crc:
    name: Test deploy-operator.sh on CRC
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            curl \
            wget \
            tar \
            gzip \
            libvirt-daemon-system \
            libvirt-clients \
            qemu-kvm \
            qemu-utils \
            libguestfs-tools \
            dnsmasq \
            netcat-openbsd \
            jq \
            podman \
            build-essential

      - name: Install OpenShift CLI (oc) and opm
        run: |
          # Try to get the OpenShift version from CRC release info
          echo "Fetching CRC release information..."
          CRC_INFO=$(curl -s --max-time 10 https://developers.redhat.com/content-gateway/rest/mirror/pub/openshift-v4/clients/crc/latest/release-info.json || echo "")
          
          if [ -n "$CRC_INFO" ] && echo "$CRC_INFO" | jq -e '.version.openshiftVersion' >/dev/null 2>&1; then
            OCP_FULL_VERSION=$(echo "$CRC_INFO" | jq -r '.version.openshiftVersion')
            OCP_MINOR_VERSION=$(echo "$OCP_FULL_VERSION" | cut -d. -f1-2)
            echo "CRC will deploy OpenShift ${OCP_FULL_VERSION}, installing matching oc and opm..."
          else
            echo "Could not determine OpenShift version from CRC info, using latest stable versions"
            OCP_FULL_VERSION="latest"
            OCP_MINOR_VERSION="latest"
          fi
          
          # Function to download and extract with validation
          download_and_extract() {
            local url=$1
            local dest_dir=$2
            local tool_name=$3
            local temp_file=$(mktemp)
            local extract_dir=$(mktemp -d)
            
            echo "Downloading from: $url"
            if ! curl -f -sL "$url" -o "$temp_file"; then
              echo "Failed to download (curl error)"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
            
            # Check file size (should be > 0)
            if [ ! -s "$temp_file" ]; then
              echo "Downloaded file is empty"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
            
            # Check if file is HTML (404 page)
            if head -1 "$temp_file" 2>/dev/null | grep -qE "<!DOCTYPE|<html"; then
              echo "Downloaded file appears to be HTML (likely 404)"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
            
            # Check if it's a valid gzip file
            if ! gzip -t "$temp_file" 2>/dev/null; then
              echo "File is not a valid gzip archive"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
            
            # Extract to temp directory first
            if ! tar -xzf "$temp_file" -C "$extract_dir" 2>/dev/null; then
              echo "Failed to extract archive"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
            
            # Find and move the binary to destination
            # For opm, it might be named opm-rhel8 or opm-rhel9, so search for any opm* file
            if [ "$tool_name" = "opm" ]; then
              local binary_path=$(find "$extract_dir" -type f -name "opm*" ! -name "*.md" ! -name "*.txt" 2>/dev/null | head -1)
            else
              local binary_path=$(find "$extract_dir" -type f -name "$tool_name" 2>/dev/null | head -1)
            fi
            
            if [ -n "$binary_path" ] && [ -f "$binary_path" ]; then
              sudo mv "$binary_path" "$dest_dir/$tool_name" 2>/dev/null
              sudo chmod +x "$dest_dir/$tool_name" 2>/dev/null
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 0
            else
              echo "Binary $tool_name not found in archive"
              rm -f "$temp_file"
              rm -rf "$extract_dir"
              return 1
            fi
          }
          
          # Install oc CLI - try multiple URL formats
          echo "Installing oc CLI..."
          OCP_OC_INSTALLED=false
          
          # Build URL list - always try latest first, then version-specific if available
          if [ "$OCP_FULL_VERSION" != "latest" ] && [ -n "$OCP_MINOR_VERSION" ] && [ "$OCP_MINOR_VERSION" != "latest" ]; then
            URL_LIST=(
              "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest/openshift-client-linux.tar.gz"
              "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest-${OCP_MINOR_VERSION}/openshift-client-linux.tar.gz"
              "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/${OCP_FULL_VERSION}/openshift-client-linux.tar.gz"
            )
          else
            URL_LIST=(
              "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest/openshift-client-linux.tar.gz"
            )
          fi
          
          for url in "${URL_LIST[@]}"; do
            if download_and_extract "$url" "/usr/local/bin" "oc"; then
              OCP_OC_INSTALLED=true
              break
            fi
          done
          
          if [ "$OCP_OC_INSTALLED" = false ]; then
            echo "ERROR: Failed to install oc CLI from any URL"
            exit 1
          fi
          oc version --client
          
          # Install opm - try multiple URL formats
          echo "Installing opm..."
          OPM_INSTALLED=false
          
          # Build URL list - always try latest first, then version-specific if available
          if [ "$OCP_FULL_VERSION" != "latest" ] && [ -n "$OCP_MINOR_VERSION" ] && [ "$OCP_MINOR_VERSION" != "latest" ]; then
            OPM_URL_LIST=(
              "https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/latest/opm-linux.tar.gz"
              "https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/latest-${OCP_MINOR_VERSION}/opm-linux.tar.gz"
              "https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/${OCP_FULL_VERSION}/opm-linux.tar.gz"
            )
          else
            OPM_URL_LIST=(
              "https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/latest/opm-linux.tar.gz"
            )
          fi
          
          for url in "${OPM_URL_LIST[@]}"; do
            if download_and_extract "$url" "/usr/local/bin" "opm"; then
              OPM_INSTALLED=true
              break
            fi
          done
          
          if [ "$OPM_INSTALLED" = false ]; then
            echo "ERROR: Failed to install opm from any URL"
            exit 1
          fi
          opm version

      - name: Install CRC
        run: |
          # Try to get CRC version from API, with fallback
          echo "Fetching CRC release information..."
          CRC_INFO=$(curl -s --max-time 10 --retry 3 https://developers.redhat.com/content-gateway/rest/mirror/pub/openshift-v4/clients/crc/latest/release-info.json || echo "")
          
          if [ -n "$CRC_INFO" ] && echo "$CRC_INFO" | jq -e '.version.crcVersion' >/dev/null 2>&1; then
            CRC_VERSION=$(echo "$CRC_INFO" | jq -r '.version.crcVersion')
            echo "Found CRC version from API: $CRC_VERSION"
          else
            # Fallback: try to get latest version from directory listing or use a known working version
            echo "Could not get version from API, trying fallback method..."
            # Try to use the links from the API response if available
            if [ -n "$CRC_INFO" ] && echo "$CRC_INFO" | jq -e '.links.linux' >/dev/null 2>&1; then
              CRC_URL=$(echo "$CRC_INFO" | jq -r '.links.linux')
              echo "Using direct download URL from API: $CRC_URL"
              wget -q "$CRC_URL" -O crc-linux-amd64.tar.xz
            else
              # Last resort: try a known recent version
              echo "Using fallback: trying to download latest CRC directly..."
              CRC_VERSION="2.56.0"  # Known working version as fallback
              echo "Using fallback version: $CRC_VERSION"
              wget -q "https://developers.redhat.com/content-gateway/file/pub/openshift-v4/clients/crc/${CRC_VERSION}/crc-linux-amd64.tar.xz" || {
                echo "ERROR: Failed to download CRC archive with fallback version"
                exit 1
              }
            fi
          fi
          
          # Download if we have a version but haven't downloaded yet
          if [ -z "$CRC_URL" ] && [ -n "$CRC_VERSION" ]; then
            echo "Installing CRC version: $CRC_VERSION"
            wget -q "https://developers.redhat.com/content-gateway/file/pub/openshift-v4/clients/crc/${CRC_VERSION}/crc-linux-amd64.tar.xz" || {
              echo "ERROR: Failed to download CRC archive"
              exit 1
            }
          fi
          
          if [ ! -f "crc-linux-amd64.tar.xz" ]; then
            echo "ERROR: CRC archive file not found after download"
            exit 1
          fi
          
          echo "Extracting CRC archive..."
          tar -xJf crc-linux-amd64.tar.xz || {
            echo "ERROR: Failed to extract CRC archive"
            exit 1
          }
          
          # Find the extracted directory
          CRC_DIR=$(find . -maxdepth 1 -type d -name "crc-linux-*" | head -1)
          if [ -z "$CRC_DIR" ] || [ ! -f "$CRC_DIR/crc" ]; then
            echo "ERROR: CRC binary not found in extracted archive"
            ls -la
            exit 1
          fi
          
          sudo mv "$CRC_DIR/crc" /usr/local/bin/
          rm -rf crc-linux-* crc-linux-amd64.tar.xz
          
          crc version

      - name: Setup CRC
        run: |
          # Configure CRC (use lower memory for GitHub Actions runners)
          crc config set consent-telemetry no
          crc config set memory 12288  # 12GB - GitHub Actions runners have ~16GB
          crc config set cpus 4        # Reduce CPUs to match available resources
          crc config set disk-size 50  # Reduce disk size
          
          # Setup CRC (download and extract bundle)
          # Use 'newgrp libvirt' to run in a new shell with libvirt group active
          # This avoids the need to logout/re-login for group membership to take effect
          # newgrp creates a new shell, so we use a here-doc to pass the command
          newgrp libvirt <<EOF
          crc setup
          EOF

      - name: Start CRC cluster
        env:
          CRC_PULL_SECRET: ${{ secrets.CRC_PULL_SECRET }}
        run: |
          if [ -z "$CRC_PULL_SECRET" ]; then
            echo "Warning: CRC_PULL_SECRET not set. CRC may fail to start."
            echo "Please add your pull secret to GitHub secrets."
          fi
          
          # Start CRC with pull secret
          if [ -n "$CRC_PULL_SECRET" ]; then
            echo "$CRC_PULL_SECRET" | crc start --pull-secret-file /dev/stdin -p ~/.crc/pull-secret.txt
          else
            # Try to start without pull secret (may fail)
            crc start || echo "CRC start failed - continuing anyway"
          fi
          
          # Wait for cluster to be ready
          timeout 300 bash -c 'until oc get nodes 2>/dev/null; do sleep 10; done' || true
          
          # Configure oc environment
          eval $(crc oc-env)
          
          # Login as admin
          oc login -u kubeadmin -p $(crc console --credentials | grep -oP 'password: \K.*') https://api.crc.testing:6443 --insecure-skip-tls-verify || true
          
          # Wait for cluster operators to be ready
          echo "Waiting for cluster operators to be ready..."
          timeout 600 bash -c 'until oc get clusteroperators 2>/dev/null && oc wait --for=condition=Available --timeout=5s clusteroperators --all 2>/dev/null; do sleep 30; done' || echo "Cluster operators may not be fully ready"

      - name: Verify cluster access
        run: |
          eval $(crc oc-env)
          oc login -u kubeadmin -p $(crc console --credentials | grep -oP 'password: \K.*') https://api.crc.testing:6443 --insecure-skip-tls-verify
          
          echo "=========================================="
          echo "Cluster Information:"
          echo "=========================================="
          oc get nodes
          echo ""
          echo "OpenShift Version:"
          oc version -o json | jq -r '.openshiftVersion // "unknown"'
          echo ""
          echo "Client Version:"
          oc version --client
          echo ""
          echo "Cluster Operators:"
          oc get clusteroperators

      - name: Make script executable
        run: |
          chmod +x deploy-operator.sh

      - name: Test script with KONFLUX_SKIP_DEPLOYMENT
        env:
          QUAY_AUTH: ${{ secrets.QUAY_AUTH }}
        run: |
          eval $(crc oc-env)
          oc login -u kubeadmin -p $(crc console --credentials | grep -oP 'password: \K.*') https://api.crc.testing:6443 --insecure-skip-tls-verify
          
          # Test 1: Skip deployment (metadata extraction only)
          echo "=== Test 1: KONFLUX_SKIP_DEPLOYMENT=true ==="
          KONFLUX_SKIP_DEPLOYMENT=true ./deploy-operator.sh --operator sriov || echo "Test completed"
          
          # Test 2: Skip operator deployment (CatalogSource only)
          echo "=== Test 2: KONFLUX_DEPLOY_OPERATOR=false ==="
          if [ -n "$QUAY_AUTH" ]; then
            KONFLUX_DEPLOY_OPERATOR=false ./deploy-operator.sh --operator sriov --quay-auth <(echo "$QUAY_AUTH") || echo "Test completed"
          else
            echo "Skipping test - QUAY_AUTH not set"
          fi
          
          # Test 3: FBC tag mode (use detected OCP version)
          echo "=== Test 3: FBC tag mode ==="
          OCP_VER=$(oc version -o json | jq -r '.openshiftVersion' | cut -d. -f1-2 || echo "4.20")
          KONFLUX_SKIP_DEPLOYMENT=true ./deploy-operator.sh --fbc-tag ocp__${OCP_VER}__metallb-rhel9-operator || echo "Test completed"

      - name: Test script validation
        run: |
          # Test script argument validation
          echo "=== Testing argument validation ==="
          
          # Should fail: no arguments
          ./deploy-operator.sh 2>&1 | grep -q "Provide either" && echo "✓ Correctly rejects missing arguments" || echo "✗ Failed to reject missing arguments"
          
          # Should fail: both --operator and --fbc-tag
          ./deploy-operator.sh --operator sriov --fbc-tag test 2>&1 | grep -q "not both" && echo "✓ Correctly rejects both arguments" || echo "✗ Failed to reject both arguments"
          
          # Should fail: invalid operator
          ./deploy-operator.sh --operator invalid-operator 2>&1 | grep -q "Invalid operator" && echo "✓ Correctly rejects invalid operator" || echo "✗ Failed to reject invalid operator"

      - name: Test with KONFLUX_SKIP_DEPLOYMENT
        run: |
          eval $(crc oc-env)
          oc login -u kubeadmin -p $(crc console --credentials | grep -oP 'password: \K.*') https://api.crc.testing:6443 --insecure-skip-tls-verify
          
          echo "=== Testing KONFLUX_SKIP_DEPLOYMENT ==="
          KONFLUX_SKIP_DEPLOYMENT=true ./deploy-operator.sh --operator sriov 2>&1 | grep -q "Skipping deployment" && echo "✓ Correctly skips deployment" || echo "✗ Failed to skip deployment"

      - name: Test environment variable controls
        env:
          QUAY_AUTH: ${{ secrets.QUAY_AUTH }}
        run: |
          eval $(crc oc-env)
          oc login -u kubeadmin -p $(crc console --credentials | grep -oP 'password: \K.*') https://api.crc.testing:6443 --insecure-skip-tls-verify
          
          echo "=== Testing environment variable controls ==="
          
          # Test KONFLUX_DEPLOY_CATALOG_SOURCE=false and KONFLUX_DEPLOY_OPERATOR=false
          if [ -n "$QUAY_AUTH" ]; then
            KONFLUX_DEPLOY_CATALOG_SOURCE=false KONFLUX_DEPLOY_OPERATOR=false \
              ./deploy-operator.sh --operator sriov --quay-auth <(echo "$QUAY_AUTH") 2>&1 | head -20 || echo "Environment variable test completed"
          else
            echo "Skipping test - QUAY_AUTH not set"
          fi

      - name: Cleanup CRC (if needed)
        if: always()
        run: |
          # Stop CRC to free resources
          crc stop || true
          crc delete -f || true

      - name: Archive logs
        if: failure()
        run: |
          eval $(crc oc-env) || true
          mkdir -p /tmp/crc-logs
          crc logs --bundle /tmp/crc-logs/crc-logs.tar.gz || true
          # Upload logs as artifact (optional)
          echo "CRC logs saved to /tmp/crc-logs/"

